{"metadata":{"generator":"Captivate","generatorVersion":"10.0.0","schemaVersion":"","author":"","title":"","description":"project description","email":"","website":"","tags":"","thumbnail":"","source":"assets","durationInFrames":41682,"frameRate":30,"totalSlides":39,"width":1280,"height":720,"responsive":false,"scalable":false,"launchFile":"index.html"},"contentStructure":[{"id":"si74830","class":"TODO::Senthil","roles":{}},{"id":"si74838","class":"TODO::Senthil","roles":{}},{"id":"Text_Caption_909","class":"TODO::Senthil","instance":"Text_Caption_909","title":"Use the buttons below to move between slides and control the audio. ","roles":{"textData":{}}},{"id":"Click_Box_56","class":"TODO::Senthil","instance":"Click_Box_56","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1218","class":"TODO::Senthil","instance":"Text_Caption_1218","title":"Introduction to the ACPI Source Language (ASL) ","roles":{"textData":{}}},{"id":"Button_680","class":"TODO::Senthil","instance":"Button_680","roles":{"click":{"subtype":"button"}}},{"id":"Slide17873","class":"Normal Slide","instance":"Title slide","thumbnail":"","children":["si74830","si74838","Text_Caption_909","Click_Box_56","Text_Caption_1218","Button_680"],"roles":{"slide":{"durationInFrames":327},"navigation":{"navid":"Slide17873"}}},{"id":"si125178","class":"TODO::Senthil","roles":{}},{"id":"si125180","class":"TODO::Senthil","roles":{}},{"id":"Text_Caption_1442","class":"TODO::Senthil","instance":"Text_Caption_1442","title":"Use the buttons below to move between slides and control the audio. ","roles":{"textData":{}}},{"id":"Click_Box_235","class":"TODO::Senthil","instance":"Click_Box_235","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1443","class":"TODO::Senthil","instance":"Text_Caption_1443","title":"Introduction to the ACPI Source Language (ASL) ","roles":{"textData":{}}},{"id":"Slide125177","class":"Normal Slide","instance":"Title slide","thumbnail":"","children":["si125178","si125180","Text_Caption_1442","Click_Box_235","Text_Caption_1443"],"roles":{"slide":{"durationInFrames":264},"navigation":{"navid":"Slide125177"}}},{"id":"si74803","class":"TODO::Senthil","roles":{}},{"id":"si116929","class":"TODO::Senthil","title":"$$cpInfoCurrentSlide$$ ","roles":{"textData":{}}},{"id":"Click_Box_178","class":"TODO::Senthil","instance":"Click_Box_178","roles":{"click":{"subtype":"button"}}},{"id":"About_This_Module_text_1208","class":"TODO::Senthil","instance":"About_This_Module_text_1208","title":"This training module provides an introduction to the ACPI Source Language (ASL), including ASL grammar and syntax.   There are two main concepts discussed in this tutorial: objects that populate the ACPI Namespace, and sequences of instructions that operate on those objects.   For more details see the other modules in this series, and the ACPI specification at http://uefi.org/specifications.   This tutorial is primarily intended for ACPI firmware developers. It may also be useful for: Operating system and device driver developers OEMs building hardware containing ACPI-compatible interfaces CPU and chipset vendors Peripheral vendors  Please allow about an hour to complete this tutorial. ","roles":{"textData":{}}},{"id":"Text_Caption_1211","class":"TODO::Senthil","instance":"Text_Caption_1211","title":"Overview Introduction to ASL Describing a Device Platform Power States Describing Processors Interrupt Routing Device Power States  ","roles":{"textData":{}}},{"id":"Green_underline_259","class":"TODO::Senthil","instance":"Green_underline_259","roles":{}},{"id":"About_This_Module_1209","class":"TODO::Senthil","instance":"About_This_Module_1209","title":"ACPI Training Outline   ","roles":{"textData":{}}},{"id":"Vertical_blue_line_260","class":"TODO::Senthil","instance":"Vertical_blue_line_260","roles":{}},{"id":"Green_underline_261","class":"TODO::Senthil","instance":"Green_underline_261","roles":{}},{"id":"What_is_ACPI_1210","class":"TODO::Senthil","instance":"What_is_ACPI_1210","title":"About this Training  ","roles":{"textData":{}}},{"id":"Slide116796","class":"Normal Slide","instance":"About this Training","thumbnail":"","children":["si74803","si116929","Click_Box_178","About_This_Module_text_1208","Text_Caption_1211","About_This_Module_1209","What_is_ACPI_1210"],"roles":{"slide":{"durationInFrames":1374},"navigation":{"navid":"Slide116796"}}},{"id":"What_is_ACPI_text_1152","class":"TODO::Senthil","instance":"What_is_ACPI_text_1152","title":"ASL is a programming language designed for describing ACPI definition block data structures. Firmware developers write ASL code by reviewing hardware component datasheets, platform board schematics, and other design collateral, and then converting relevant details into definition block code stored in an ASL file.   ASL files are translated by a compiler into AML bytecode, which is stored with other firmware components in a computer’s non-volatile memory. Note that ASL and AML are closely related but separate languages.  ","roles":{"textData":{}}},{"id":"Green_underline_242","class":"TODO::Senthil","instance":"Green_underline_242","roles":{}},{"id":"What_is_ACPI_1153","class":"TODO::Senthil","instance":"What_is_ACPI_1153","title":"ASL Overview  ","roles":{"textData":{}}},{"id":"Click_Box_165","class":"TODO::Senthil","instance":"Click_Box_165","roles":{"click":{"subtype":"button"}}},{"id":"Image_295","class":"TODO::Senthil","instance":"Image_295","roles":{}},{"id":"Slide115607","class":"Normal Slide","instance":"ASL Overview","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1152","What_is_ACPI_1153","Click_Box_165","Image_295"],"roles":{"slide":{"durationInFrames":1014},"navigation":{"navid":"Slide115607"}}},{"id":"Green_underline_295","class":"TODO::Senthil","instance":"Green_underline_295","roles":{}},{"id":"What_is_ACPI_1331","class":"TODO::Senthil","instance":"What_is_ACPI_1331","title":"ASL Overview  ","roles":{"textData":{}}},{"id":"Click_Box_210","class":"TODO::Senthil","instance":"Click_Box_210","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1332","class":"TODO::Senthil","instance":"Text_Caption_1332","title":"When a computer loads firmware from non-volatile memory, the AML bytecode for ACPI tables gets copied into random-access memory (RAM). These tables are then updated (patched) using key values identified during the boot process, such as starting memory addresses.   At OS boot, an AML interpreter in the OS uses the updated ACPI tables to create ACPI Namespace objects. An ACPI-compatible OS must include an AML bytecode interpreter.   ACPI tables are loaded into memory during the firmware boot process, and parsed to create the ACPI Namespace during the OS boot process. Information in the Namespace is then available to drivers.   ","roles":{"textData":{}}},{"id":"Image_298","class":"TODO::Senthil","instance":"Image_298","roles":{}},{"id":"Slide119646","class":"Normal Slide","instance":"ASL Overview","thumbnail":"","children":["si74803","si116929","What_is_ACPI_1331","Click_Box_210","Text_Caption_1332","Image_298"],"roles":{"slide":{"durationInFrames":1233},"navigation":{"navid":"Slide119646"}}},{"id":"What_is_ACPI_text_1043","class":"TODO::Senthil","instance":"What_is_ACPI_text_1043","title":"The sample ASL code shown here is an example of a Definition Block, containing various named objects.  Technically, these objects become part of the ACPI Namespace when that is constructed by the AML interpreter at runtime. However, some firmware developers also refer to the ASL source code or definition blocks as the Namespace. In this tutorial, the term Namespace is used interchangeably to refer to both the original ASL code, and the structures created by the AML interpreter.  ","roles":{"textData":{}}},{"id":"Green_underline_191","class":"TODO::Senthil","instance":"Green_underline_191","roles":{}},{"id":"What_is_ACPI_1044","class":"TODO::Senthil","instance":"What_is_ACPI_1044","title":"ASL Example ","roles":{"textData":{}}},{"id":"Click_Box_120","class":"TODO::Senthil","instance":"Click_Box_120","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1146","class":"TODO::Senthil","instance":"Text_Caption_1146","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"ASL001\", \"ASLTour\", 0x00000001) {   Scope (\\_SB){     Device (PCI0){       Name (_HID, ...)       Name (_CID, ...)       Method (BN00){          ...       }       Method (_BBN){         ...       }     }   }    OperationRegion (MCHT,...)   Field (MCHT){     RPSL,   8,     Offset (0x5998),     RP0C,   8,     RP1C,   8,   } } ","roles":{"textData":{}}},{"id":"Slide112989","class":"Normal Slide","instance":"ASL Example","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1043","What_is_ACPI_1044","Click_Box_120","Text_Caption_1146"],"roles":{"slide":{"durationInFrames":882},"navigation":{"navid":"Slide112989"}}},{"id":"What_is_ACPI_text_1041","class":"TODO::Senthil","instance":"What_is_ACPI_text_1041","title":"The ACPI Namespace is a tree-like data structure that maps variable names to internal objects. An AML interpreter in the OS creates the ACPI Namespace by parsing AML bytecode.  Internal objects associated with ACPI variable names represent data, device hierarchies, and subroutines that are used for configuration and power management. These objects are evaluated according to the ACPI specification, and may result in changes to registers owned by the AML interpreter or the ACPI namespace.  When the ACPI subsystem is queried by the operating system, the subsystem searches the Namespace for the requested variable, evaluates the object associated with the name, and returns the result of the computation.  ","roles":{"textData":{}}},{"id":"Green_underline_190","class":"TODO::Senthil","instance":"Green_underline_190","roles":{}},{"id":"What_is_ACPI_1042","class":"TODO::Senthil","instance":"What_is_ACPI_1042","title":"ACPI Namespace  ","roles":{"textData":{}}},{"id":"Click_Box_119","class":"TODO::Senthil","instance":"Click_Box_119","roles":{"click":{"subtype":"button"}}},{"id":"Image_288","class":"TODO::Senthil","instance":"Image_288","roles":{}},{"id":"Slide112939","class":"Normal Slide","instance":"ACPI Namespace","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1041","What_is_ACPI_1042","Click_Box_119","Image_288"],"roles":{"slide":{"durationInFrames":1308},"navigation":{"navid":"Slide112939"}}},{"id":"What_is_ACPI_text_1154","class":"TODO::Senthil","instance":"What_is_ACPI_text_1154","title":"When a file containing ASL is compiled, the result is packaged as firmware. During the initialization of the OS, a namespace hierarchy is created and helps the OS find devices and initialize drivers for them. The following diagram illustrates this concept.  ","roles":{"textData":{}}},{"id":"Green_underline_243","class":"TODO::Senthil","instance":"Green_underline_243","roles":{}},{"id":"What_is_ACPI_1155","class":"TODO::Senthil","instance":"What_is_ACPI_1155","title":"Namespace Hierarchy ","roles":{"textData":{}}},{"id":"Click_Box_166","class":"TODO::Senthil","instance":"Click_Box_166","roles":{"click":{"subtype":"button"}}},{"id":"Image_285","class":"TODO::Senthil","instance":"Image_285","roles":{}},{"id":"Slide115696","class":"Normal Slide","instance":"Namespace Hierarchy","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1154","What_is_ACPI_1155","Click_Box_166","Image_285"],"roles":{"slide":{"durationInFrames":492},"navigation":{"navid":"Slide115696"}}},{"id":"What_is_ACPI_text_1213","class":"TODO::Senthil","instance":"What_is_ACPI_text_1213","title":"ASL has two kinds of operators: ones that create variables and data to populate the ACPI Namespace, and ones that perform actions on data. This section discusses how to write ASL code, which is used by the OS to build the Namespace.  ASL syntax is similar to the C programming language in the following ways:  Both single line (//) and multi-line (/* … */) comments are allowed White spaces and indentation are ignored. Semi-colons are optional after each ASL term There is no boolean type. Instead, the value 0 means “false” and all values greater than 0 mean “true”. Curly brackets {} are used for scopes and loops.  ASL also has notable differences compared to standard programming languages, including unique data types and scoping rules. ","roles":{"textData":{}}},{"id":"Green_underline_262","class":"TODO::Senthil","instance":"Green_underline_262","roles":{}},{"id":"What_is_ACPI_1214","class":"TODO::Senthil","instance":"What_is_ACPI_1214","title":"ASL Syntax ","roles":{"textData":{}}},{"id":"Click_Box_179","class":"TODO::Senthil","instance":"Click_Box_179","roles":{"click":{"subtype":"button"}}},{"id":"Slide116886","class":"Normal Slide","instance":"ASL Syntax","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1213","What_is_ACPI_1214","Click_Box_179"],"roles":{"slide":{"durationInFrames":1446},"navigation":{"navid":"Slide116886"}}},{"id":"What_is_ACPI_text_966","class":"TODO::Senthil","instance":"What_is_ACPI_text_966","title":"The fundamental ASL language construct is a DefinitionBlock, which is also referred to as an ASL table (see the first example shown here).   A DefinitionBlock includes a list of ASL terms that add variable names to the ACPI Namespace. ASL terms must be contained inside a DefinitionBlock to be valid when processed by the AML compiler.  ","roles":{"textData":{}}},{"id":"Green_underline_156","class":"TODO::Senthil","instance":"Green_underline_156","roles":{}},{"id":"What_is_ACPI_967","class":"TODO::Senthil","instance":"What_is_ACPI_967","title":"Definition Blocks ","roles":{"textData":{}}},{"id":"Click_Box_92","class":"TODO::Senthil","instance":"Click_Box_92","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1148","class":"TODO::Senthil","instance":"Text_Caption_1148","title":"  DefinitionBlock (     AMLFileName,         // name of the AML file (string)      TableSignature,      // signature of the AML file (could be DSDT or SSDT) (4-character string)     ComplianceRevision,  // a value of 2 or greater enables 64-bit arithmetic,                            // a value of 1 or less enables 32-bit arithmetic (8 bit unsigned integer)      OEMID,               // a six-character string assigned by the OEM     TableID,             // a specific identifier for the table (8-character String)      OEMRevision          // revision number set by the OEM (32-bit number)   )   {     TermList             // a list of ASL terms   }  ","roles":{"textData":{}}},{"id":"What_is_ACPI_text_1275","class":"TODO::Senthil","instance":"What_is_ACPI_text_1275","title":"Note that the first DefinitionBlock example on this page can be simplified as shown in the second example here, and this simplified format will be used for the remainder of this tutorial.     ","roles":{"textData":{}}},{"id":"Text_Caption_1276","class":"TODO::Senthil","instance":"Text_Caption_1276","title":"  DefinitionBlock (\"\", DSDT, 2, \"\", \"\", 0x0)   {     // A list of ASL terms   } ","roles":{"textData":{}}},{"id":"Slide111028","class":"Normal Slide","instance":"Definition Blocks","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_966","What_is_ACPI_967","Click_Box_92","Text_Caption_1148","What_is_ACPI_text_1275","Text_Caption_1276"],"roles":{"slide":{"durationInFrames":936},"navigation":{"navid":"Slide111028"}}},{"id":"What_is_ACPI_text_1054","class":"TODO::Senthil","instance":"What_is_ACPI_text_1054","title":"The format of a named ASL object as defined in the ACPI Specification is shown here.             This creates a new object in the ACPI Namespace called ObjectName, and assigns it the value Object.  ","roles":{"textData":{}}},{"id":"Green_underline_196","class":"TODO::Senthil","instance":"Green_underline_196","roles":{}},{"id":"What_is_ACPI_1055","class":"TODO::Senthil","instance":"What_is_ACPI_1055","title":"Named Objects ","roles":{"textData":{}}},{"id":"Click_Box_125","class":"TODO::Senthil","instance":"Click_Box_125","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1366","class":"TODO::Senthil","instance":"Text_Caption_1366","title":" Name (ObjectName, Object) ","roles":{"textData":{}}},{"id":"Text_Caption_1418","class":"TODO::Senthil","instance":"Text_Caption_1418","title":"ObjectName, or NameSeg (short for name segment), consists of 1-4 characters with the following characteristics: The first character can be either a letter or an underscore (_) Three more additional characters can be letters, numbers, or underscores. ObjectNames shorter than four characters are padded with trailing underscores by the compiler. Any lowercase letters get converted to uppercase during compilation, so it is highly recommended to use uppercase letters only as a best practice.  ","roles":{"textData":{}}},{"id":"Slide113279","class":"Normal Slide","instance":"Named Objects","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1054","What_is_ACPI_1055","Click_Box_125","Text_Caption_1366","Text_Caption_1418"],"roles":{"slide":{"durationInFrames":1206},"navigation":{"navid":"Slide113279"}}},{"id":"Green_underline_322","class":"TODO::Senthil","instance":"Green_underline_322","roles":{}},{"id":"What_is_ACPI_1424","class":"TODO::Senthil","instance":"What_is_ACPI_1424","title":"ObjectName Examples ","roles":{"textData":{}}},{"id":"Click_Box_234","class":"TODO::Senthil","instance":"Click_Box_234","roles":{"click":{"subtype":"button"}}},{"id":"What_is_ACPI_text_1427","class":"TODO::Senthil","instance":"What_is_ACPI_text_1427","title":"The first set of examples shown to the right are valid named object declarations. For the last two items in this set, the ObjectName will get padded with trailing underscores by the compiler.   ","roles":{"textData":{}}},{"id":"Text_Caption_1428","class":"TODO::Senthil","instance":"Text_Caption_1428","title":"Name (UPPR, 0x0) Name (BUF3, Buffer(3){}) Name (_STA, 0x0)          // predefined name Name (ABC,0x0) Name (X,0x0)  ","roles":{"textData":{}}},{"id":"Text_Caption_1429","class":"TODO::Senthil","instance":"Text_Caption_1429","title":"Name (!@#~, 0x0)   Name (TOOLONG, 0x0)      Name (,0x0)   ","roles":{"textData":{}}},{"id":"Text_Caption_1430","class":"TODO::Senthil","instance":"Text_Caption_1430","title":"The last three examples here are not allowed: the first one because it doesn’t start with a letter or underscore, the second because the nameseg is too long, and the last one because it does not contain a nameseg.  ","roles":{"textData":{}}},{"id":"Text_Caption_1431","class":"TODO::Senthil","instance":"Text_Caption_1431","title":"The next two examples shown here are technically allowed but not recommended, because of the conversion to uppercase mentioned earlier. Use upper case letters only in ObjectName as a best practice.  ","roles":{"textData":{}}},{"id":"Text_Caption_1432","class":"TODO::Senthil","instance":"Text_Caption_1432","title":"Name (lowr, 0x0)   Name (MiXd, 0x0)   ","roles":{"textData":{}}},{"id":"Slide124189","class":"Normal Slide","instance":"ObjectName Examples","thumbnail":"","children":["si74803","si116929","What_is_ACPI_1424","Click_Box_234","What_is_ACPI_text_1427","Text_Caption_1428","Text_Caption_1429","Text_Caption_1430","Text_Caption_1431","Text_Caption_1432"],"roles":{"slide":{"durationInFrames":954},"navigation":{"navid":"Slide124189"}}},{"id":"What_is_ACPI_text_1057","class":"TODO::Senthil","instance":"What_is_ACPI_text_1057","title":"The simplest way to add a named object to the ASL Namespace is by using the Name keyword, as shown in the example here.  ","roles":{"textData":{}}},{"id":"Green_underline_197","class":"TODO::Senthil","instance":"Green_underline_197","roles":{}},{"id":"What_is_ACPI_1058","class":"TODO::Senthil","instance":"What_is_ACPI_1058","title":"Populating the ACPI Namespace ","roles":{"textData":{}}},{"id":"Click_Box_126","class":"TODO::Senthil","instance":"Click_Box_126","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1290","class":"TODO::Senthil","instance":"Text_Caption_1290","title":"DefinitionBlock (\"\", DSDT, 2, \"\", \"\", 0x0) {     Name(OBJ0, 0x1234)     Name(OBJ1, \"Hello World\") } ","roles":{"textData":{}}},{"id":"Image_303","class":"TODO::Senthil","instance":"Image_303","roles":{}},{"id":"Text_Caption_1417","class":"TODO::Senthil","instance":"Text_Caption_1417","title":"This block of ASL adds named objects called OBJ0 and OBJ1 to the ACPI Namespace. Object OBJ0 is assigned the integer value 0x1234, and object OBJ1 is assigned the string “Hello World”.  ","roles":{"textData":{}}},{"id":"Slide113339","class":"Normal Slide","instance":"Populating the ACPI Namespace","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1057","What_is_ACPI_1058","Click_Box_126","Text_Caption_1290","Image_303","Text_Caption_1417"],"roles":{"slide":{"durationInFrames":675},"navigation":{"navid":"Slide113339"}}},{"id":"What_is_ACPI_text_1352","class":"TODO::Senthil","instance":"What_is_ACPI_text_1352","title":"ASL also includes unique data types that will be described later, designed to describe devices, bitfields, and other low-level constructs (for example Device, OperationRegion, and ThermalZones).   ","roles":{"textData":{}}},{"id":"Green_underline_301","class":"TODO::Senthil","instance":"Green_underline_301","roles":{}},{"id":"What_is_ACPI_1353","class":"TODO::Senthil","instance":"What_is_ACPI_1353","title":"Simple ASL Data Types ","roles":{"textData":{}}},{"id":"Click_Box_216","class":"TODO::Senthil","instance":"Click_Box_216","roles":{"click":{"subtype":"button"}}},{"id":"SmartShape_145","class":"TODO::Senthil","instance":"SmartShape_145","title":"Integer ","roles":{"click":{"subtype":"button"},"textData":{}}},{"id":"Click_Box_217","class":"TODO::Senthil","instance":"Click_Box_217","roles":{"click":{"subtype":"button"}}},{"id":"SmartShape_150","class":"TODO::Senthil","instance":"SmartShape_150","title":"String ","roles":{"click":{"subtype":"button"},"textData":{}}},{"id":"Click_Box_222","class":"TODO::Senthil","instance":"Click_Box_222","roles":{"click":{"subtype":"button"}}},{"id":"SmartShape_151","class":"TODO::Senthil","instance":"SmartShape_151","title":"Buffer ","roles":{"click":{"subtype":"button"},"textData":{}}},{"id":"Click_Box_223","class":"TODO::Senthil","instance":"Click_Box_223","roles":{"click":{"subtype":"button"}}},{"id":"SmartShape_152","class":"TODO::Senthil","instance":"SmartShape_152","title":"Package ","roles":{"click":{"subtype":"button"},"textData":{}}},{"id":"Click_Box_224","class":"TODO::Senthil","instance":"Click_Box_224","roles":{"click":{"subtype":"button"}}},{"id":"SmartShape_153","class":"TODO::Senthil","instance":"SmartShape_153","title":"Object Reference ","roles":{"click":{"subtype":"button"},"textData":{}}},{"id":"Click_Box_225","class":"TODO::Senthil","instance":"Click_Box_225","roles":{"click":{"subtype":"button"}}},{"id":"SmartShape_154","class":"TODO::Senthil","instance":"SmartShape_154","title":"Method ","roles":{"click":{"subtype":"button"},"textData":{}}},{"id":"Click_Box_226","class":"TODO::Senthil","instance":"Click_Box_226","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1355","class":"TODO::Senthil","instance":"Text_Caption_1355","title":"In ASL, the Name objects also have a type. In a previous example, OBJ0 was assigned the value 0x1234, and OBJ1 was assigned the text string “Hello World”. In this case, OBJ0 is an Integer and OBJ1 is a String type. The types shown here are similar to ones that appear in other programming languages (click on the buttons to see more details):  ","roles":{"textData":{}}},{"id":"Success_Caption_11","class":"TODO::Senthil","instance":"Success_Caption_11","title":"An Integer is an unsigned 32-bit or 64-bit integer.  The size depends on the ComplianceRevision field in the DefinitionBlock. Example:  Name (INT0, 0x12345678) ","roles":{"textData":{}}},{"id":"Success_Caption_12","class":"TODO::Senthil","instance":"Success_Caption_12","title":"A string is a null-terminated ASCII string. Example: Name (STR0, “STR0 is is a string”) ","roles":{"textData":{}}},{"id":"Success_Caption_13","class":"TODO::Senthil","instance":"Success_Caption_13","title":"An buffer is an array of bytes. Example:  Name (BUF0, Buffer (){0xde,0xad, 0xbe, 0xef}) ","roles":{"textData":{}}},{"id":"Success_Caption_14","class":"TODO::Senthil","instance":"Success_Caption_14","title":"A package is an array of ASL objects. Example:  Name (PKG0, Package() {INT0, STR0, BUF0, Package()                                                                                                   {0x1234, “This is another string”}}) ","roles":{"textData":{}}},{"id":"Success_Caption_15","class":"TODO::Senthil","instance":"Success_Caption_15","title":"An Object Reference is a reference to an object created by RefOf, Index, or CondRefOf operators. Examples:  PKG0[0x0]  RefOf (INT0) ","roles":{"textData":{}}},{"id":"Success_Caption_16","class":"TODO::Senthil","instance":"Success_Caption_16","title":"A method is an executable AML function, also called a control method. Example:  Method (_SRS, 1, NotSerialized) {   CreateWordField (Arg0, One, IRQW)   Local1 = \\_SB.PCI0.PID1.IENA   Local1 |= IRQW   \\_SB.PCI0.PID1.IENA = Local1   FindSetRightBit (IRQW, Local0)   If (Local0)   {     Local0--     \\_SB.PCI0.PID1.IN01 = Local0   } } ","roles":{"textData":{}}},{"id":"Slide120437","class":"Normal Slide","instance":"Simple ASL data types","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1352","What_is_ACPI_1353","Click_Box_216","SmartShape_145","Click_Box_217","SmartShape_150","Click_Box_222","SmartShape_151","Click_Box_223","SmartShape_152","Click_Box_224","SmartShape_153","Click_Box_225","SmartShape_154","Click_Box_226","Text_Caption_1355","Success_Caption_11","Success_Caption_12","Success_Caption_13","Success_Caption_14","Success_Caption_15","Success_Caption_16"],"roles":{"slide":{"durationInFrames":1107},"navigation":{"navid":"Slide120437"}}},{"id":"What_is_ACPI_text_1063","class":"TODO::Senthil","instance":"What_is_ACPI_text_1063","title":"Integer and String objects are defined in ASL using the Name keyword. Buffer and Package objects also use similar syntax, but require additional keywords.   Here are some examples of valid buffer definitions:     The use of the buffer as a parameter indicates that the contents inside  { }  are encoded as a buffer. Each element of the comma-separated list is a value between 0x00 and 0xff. There is an optional parameter to this operand that denotes the length of the buffer. If the length parameter is not present, a length will be automatically inserted during compilation. If there are no entries inside { }, then the compiler initializes the buffer with the specified number of zeroes.      ","roles":{"textData":{}}},{"id":"Green_underline_200","class":"TODO::Senthil","instance":"Green_underline_200","roles":{}},{"id":"What_is_ACPI_1064","class":"TODO::Senthil","instance":"What_is_ACPI_1064","title":"ASL Buffers and Package Declarations ","roles":{"textData":{}}},{"id":"Click_Box_129","class":"TODO::Senthil","instance":"Click_Box_129","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1299","class":"TODO::Senthil","instance":"Text_Caption_1299","title":"Name (BUF1, Buffer(3){0x00, 0x01, 0x02}) Name (BUF2, Buffer(){0x00, 0x01, 0x02, 0x03}) Name (BUF3, Buffer(3){}) ","roles":{"textData":{}}},{"id":"Slide113489","class":"Normal Slide","instance":"ASL Buffers and Package","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1063","What_is_ACPI_1064","Click_Box_129","Text_Caption_1299"],"roles":{"slide":{"durationInFrames":1263},"navigation":{"navid":"Slide113489"}}},{"id":"What_is_ACPI_text_1065","class":"TODO::Senthil","instance":"What_is_ACPI_text_1065","title":"An ASL package is a list containing many different types of data. The elements of packages can be Integer, String, Buffer, Package or other named objects. The example to the right shows various package declarations.   Notice that PKG3 contains two elements that are packages. ASL supports multiple nesting of packages. This is similar to n-dimensional arrays in languages like C. However, ASL packages can contain different types within packages. PKG4 is a package containing a string and a package, which is also a valid package declaration.  ","roles":{"textData":{}}},{"id":"Green_underline_201","class":"TODO::Senthil","instance":"Green_underline_201","roles":{}},{"id":"What_is_ACPI_1066","class":"TODO::Senthil","instance":"What_is_ACPI_1066","title":"ASL Buffer and Package Declarations ","roles":{"textData":{}}},{"id":"Click_Box_130","class":"TODO::Senthil","instance":"Click_Box_130","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1300","class":"TODO::Senthil","instance":"Text_Caption_1300","title":"    Name (INT1, 0xABCD)     Name (PKG1, Package(3){0x1234, \"Hello world\", INT1})     Name (PKG2, Package(){INT1, \"Good bye\"})     Name (PKG3,         Package(){             Package() {0x00, 0x01, 0x02},             Package() {0x03, 0x04, 0x05}     })     Name (PKG4, Package(){             \"ASL is fun\",             Package() {0xff, 0xfe, 0xfd, 0xfc, fb}     })     Name (PKG5, Package(){         0x4321,         buffer() {0x1}     }) ","roles":{"textData":{}}},{"id":"Slide113539","class":"Normal Slide","instance":"ASL Buffers and Package","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1065","What_is_ACPI_1066","Click_Box_130","Text_Caption_1300"],"roles":{"slide":{"durationInFrames":1008},"navigation":{"navid":"Slide113539"}}},{"id":"What_is_ACPI_text_1069","class":"TODO::Senthil","instance":"What_is_ACPI_text_1069","title":"ASL code may need to access system memory or hardware registers in ASL. These registers may contain settings that were configured by platform firmware during boot, or may be used to apply settings during runtime. Examples may include changing the power state of a particular device, reading and clearing event status bits, or reading and setting values for GPIOs. These registers and regions can be defined in ASL with the OperationRegion keyword and the Field keyword.   OperationRegion defines a named object as a certain type (such as SystemMemory, SystemIO, or PCIConfig). The Field keyword defines individual bit fields inside of an OperationRegion. The indiviual fields are used to access data in control methods in this operation region. The example here declares an OperationRegion and several fields.   ","roles":{"textData":{}}},{"id":"Green_underline_203","class":"TODO::Senthil","instance":"Green_underline_203","roles":{}},{"id":"What_is_ACPI_1070","class":"TODO::Senthil","instance":"What_is_ACPI_1070","title":"Operation Regions and Fields ","roles":{"textData":{}}},{"id":"Click_Box_132","class":"TODO::Senthil","instance":"Click_Box_132","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1301","class":"TODO::Senthil","instance":"Text_Caption_1301","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x1) {    OperationRegion(OPR1, SystemMemory, 0x10000, 0x5)    Field (OPR1, )    {        FLD1, 8        FLD2, 8        Offset (3), //Start the next field unit at byte offset 3        FLD3, 4        FLD4, 12    } }  ","roles":{"textData":{}}},{"id":"Slide113639","class":"Normal Slide","instance":"Operation Regions and Field","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1069","What_is_ACPI_1070","Click_Box_132","Text_Caption_1301"],"roles":{"slide":{"durationInFrames":1512},"navigation":{"navid":"Slide113639"}}},{"id":"What_is_ACPI_text_1071","class":"TODO::Senthil","instance":"What_is_ACPI_text_1071","title":"The operation region shown here is called OPR1, and represents system memory starting at address 0x10000 with a length of 5 bytes. FLD1 through FLD4 are declared inside of OPR1. FLD1 and FLD2 span 8 bits each, while FLD3 starts at byte offset 3 and spans 4 bits, and FLD4 spans 12 bits. The primary motivation for operation region and field declaration is to read and write values to FLD1 through FLD4 inside of control methods (discussed later).   ","roles":{"textData":{}}},{"id":"Green_underline_204","class":"TODO::Senthil","instance":"Green_underline_204","roles":{}},{"id":"What_is_ACPI_1072","class":"TODO::Senthil","instance":"What_is_ACPI_1072","title":"Operation Regions and Fields ","roles":{"textData":{}}},{"id":"Click_Box_133","class":"TODO::Senthil","instance":"Click_Box_133","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1326","class":"TODO::Senthil","instance":"Text_Caption_1326","title":"    OperationRegion(OPR1, SystemMemory, 0x10000, 0x4)     Field (OPR1)     {         FLD1, 8,         FLD2, 8,         FLD3, 4,         FLD4, 12,     }  ","roles":{"textData":{}}},{"id":"Text_Caption_1416","class":"TODO::Senthil","instance":"Text_Caption_1416","title":"In this code example for OperationRegion of SystemMemory, the values for FLD1 through FLD4 are initialized to the values to be present at that address at boot time.  There are many other OperationRegions besides SystemMemory, as described in the ACPI specification.  ","roles":{"textData":{}}},{"id":"Image_318","class":"TODO::Senthil","instance":"Image_318","roles":{}},{"id":"Slide113689","class":"Normal Slide","instance":"Operation Regions and Field","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1071","What_is_ACPI_1072","Click_Box_133","Text_Caption_1326","Text_Caption_1416","Image_318"],"roles":{"slide":{"durationInFrames":1563},"navigation":{"navid":"Slide113689"}}},{"id":"What_is_ACPI_text_1100","class":"TODO::Senthil","instance":"What_is_ACPI_text_1100","title":"One role of ASL is to describe components that are not otherwise enumerable. An ASL Device object represents a device and defines a scope, which is a collection of named objects. The contents of a scope provide information about a device.     ","roles":{"textData":{}}},{"id":"Click_Box_147","class":"TODO::Senthil","instance":"Click_Box_147","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1136","class":"TODO::Senthil","instance":"Text_Caption_1136","title":"In the code example above, the curly braces after Device (DEV1) represent the scope of the device. INT1, STR1, BUF1, and PKG1 contain information about DEV1. This results in a namespace that looks like the diagram to the right.  ","roles":{"textData":{}}},{"id":"Image_265","class":"TODO::Senthil","instance":"Image_265","roles":{}},{"id":"Green_underline_235","class":"TODO::Senthil","instance":"Green_underline_235","roles":{}},{"id":"What_is_ACPI_1139","class":"TODO::Senthil","instance":"What_is_ACPI_1139","title":"Defining Scopes ","roles":{"textData":{}}},{"id":"Text_Caption_1302","class":"TODO::Senthil","instance":"Text_Caption_1302","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x1) {     Name (OBJ0, 0x1234)     Name (OBJ1, \"Hello world!\")     Device (DEV1)     {         Name (INT1, 0x1234)         Name (STR1, \"This string is inside of DEV1's scope\")         Name (BUF1, Buffer() {0x00, 0x04, 0x6f})         Name (PKG1, Package() {OBJ0, OBJ1})     } } ","roles":{"textData":{}}},{"id":"Slide114412","class":"Normal Slide","instance":"Defining Scopes","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1100","Click_Box_147","Text_Caption_1136","Image_265","What_is_ACPI_1139","Text_Caption_1302"],"roles":{"slide":{"durationInFrames":1059},"navigation":{"navid":"Slide114412"}}},{"id":"What_is_ACPI_text_1102","class":"TODO::Senthil","instance":"What_is_ACPI_text_1102","title":"Device declarations can be nested, as shown here.  In this example, USB1 and USB2 are nested within USBH.   Once the ACPI namespace is populated, the OS will start searching for various named objects to initialize device drivers. In order to do so, the OS looks for named objects that have a predefined meaning and uses the data as specified. Examples in this training include the sample names INT1, STR1, BUF1, PKG1.     ","roles":{"textData":{}}},{"id":"Click_Box_148","class":"TODO::Senthil","instance":"Click_Box_148","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_236","class":"TODO::Senthil","instance":"Green_underline_236","roles":{}},{"id":"What_is_ACPI_1140","class":"TODO::Senthil","instance":"What_is_ACPI_1140","title":"Defining Scopes ","roles":{"textData":{}}},{"id":"Text_Caption_1306","class":"TODO::Senthil","instance":"Text_Caption_1306","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x1) {     Name (OBJ0, 0xffff)     Name (OBJ1, \"Dummy USB example\")      // USB host controller     // This device can contain many ports      Device (USBH)     {         Device (USB1) // USB port #1         {             Name (INT1, 0x1234)             Name (STR1, \"USB port 1\")             Name (BUF1, Buffer() {0x00, 0x04, 0x6f})             Name (PKG1, Package() {OBJ0, OBJ1})         }         Device (USB2) // USB port #2         {             Name (INT1, 0xABCD)             Name (STR1, \"USB port 2\")             Name (BUF1, Buffer() {0x01, 0x05, 0x70})             Name (PKG1, Package() {OBJ0, OBJ1})         }     } }  ","roles":{"textData":{}}},{"id":"Slide114462","class":"Normal Slide","instance":"Defining Scopes","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1102","Click_Box_148","What_is_ACPI_1140","Text_Caption_1306"],"roles":{"slide":{"durationInFrames":1368},"navigation":{"navid":"Slide114462"}}},{"id":"Click_Box_206","class":"TODO::Senthil","instance":"Click_Box_206","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1304","class":"TODO::Senthil","instance":"Text_Caption_1304","title":"In the previous example, USBH represents a device that serves as a parent of USB1 and USB2. This hierarchy of named objects may be useful in describing large devices.   For example, a USB controller may have many USB ports. Each port can be described as a separate device that is a part of the USB controller. This results in a namespace that looks like the diagram shown here.    Notice that USB1 and USB2 contain separate objects with the same name. This is allowed because these objects are in a different scope. If they were defined under the same scope, this would result in a compiler error because it is illegal to declare two named objects that have the same NameSeg in the same scope.   ASL does not allow multiple definitions of the same name within the same scope. This is similar to many other programming languages.  ","roles":{"textData":{}}},{"id":"Image_296","class":"TODO::Senthil","instance":"Image_296","roles":{}},{"id":"Green_underline_291","class":"TODO::Senthil","instance":"Green_underline_291","roles":{}},{"id":"What_is_ACPI_1305","class":"TODO::Senthil","instance":"What_is_ACPI_1305","title":"Defining Scopes ","roles":{"textData":{}}},{"id":"Slide119149","class":"Normal Slide","instance":"Defining Scopes","thumbnail":"","children":["si74803","si116929","Click_Box_206","Text_Caption_1304","Image_296","What_is_ACPI_1305"],"roles":{"slide":{"durationInFrames":1644},"navigation":{"navid":"Slide119149"}}},{"id":"Green_underline_219","class":"TODO::Senthil","instance":"Green_underline_219","roles":{}},{"id":"What_is_ACPI_1105","class":"TODO::Senthil","instance":"What_is_ACPI_1105","title":"Name Paths ","roles":{"textData":{}}},{"id":"Click_Box_149","class":"TODO::Senthil","instance":"Click_Box_149","roles":{"click":{"subtype":"button"}}},{"id":"Image_267","class":"TODO::Senthil","instance":"Image_267","roles":{}},{"id":"What_is_ACPI_text_1104","class":"TODO::Senthil","instance":"What_is_ACPI_text_1104","title":"The previous namespace example contains nested scopes. Any named object can be referenced by its full pathname. The figure here shows the namespace annotated with full pathnames for each named object. ","roles":{"textData":{}}},{"id":"Text_Caption_1141","class":"TODO::Senthil","instance":"Text_Caption_1141","title":"The root scope can be represented with a backslash (\\). Therefore, \\OBJ0 indicates that OBJ0 is defined at the root scope.   A period (.) symbol is used as a path separator. For example,  USB1 is declared inside of USBH and can be referenced as \\USBH.USB1. This indicates that USB1 is in USBH’s scope.  For any named object that defines a scope, the period symbol indicates that the NameSeg after the symbol is inside the scope of the NameSeg before the symbol. For INT1 declared in USB1, the full pathname would be \\USBH.USB1.INT1. ","roles":{"textData":{}}},{"id":"Slide114512","class":"Normal Slide","instance":"Name Paths","thumbnail":"","children":["si74803","si116929","What_is_ACPI_1105","Click_Box_149","Image_267","What_is_ACPI_text_1104","Text_Caption_1141"],"roles":{"slide":{"durationInFrames":1668},"navigation":{"navid":"Slide114512"}}},{"id":"What_is_ACPI_text_1106","class":"TODO::Senthil","instance":"What_is_ACPI_text_1106","title":"Objects with namesegs that start with an underscrore (_) have their semantics defined by the ACPI specification. For example, when _HID is defined for a device, it contains the hardware ID associated with that device. According to the ACPI specification, _HID needs to be defined with data that is either a string or an integer.   _CRS is another example of a predefined name that returns a buffer representing the current resource setting.   ","roles":{"textData":{}}},{"id":"Green_underline_220","class":"TODO::Senthil","instance":"Green_underline_220","roles":{}},{"id":"What_is_ACPI_1107","class":"TODO::Senthil","instance":"What_is_ACPI_1107","title":"Predefined Names ","roles":{"textData":{}}},{"id":"Click_Box_150","class":"TODO::Senthil","instance":"Click_Box_150","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1142","class":"TODO::Senthil","instance":"Text_Caption_1142","title":"In a typical real-world example, there would be many other predefined named objects. A list of available predefined names and their meanings can be found in the ACPI specification. More details about device descriptions are also provided in the the corresponding training module in this series.     ","roles":{"textData":{}}},{"id":"Text_Caption_1367","class":"TODO::Senthil","instance":"Text_Caption_1367","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x1) {     Device (DEV1)     {         Name (_HID, “ACPI0010”)         Name (_CRS, Buffer() {})     } } ","roles":{"textData":{}}},{"id":"Slide114562","class":"Normal Slide","instance":"Predefined Names","thumbnail":"","children":["si74803","si116929","What_is_ACPI_text_1106","What_is_ACPI_1107","Click_Box_150","Text_Caption_1142","Text_Caption_1367"],"roles":{"slide":{"durationInFrames":1644},"navigation":{"navid":"Slide114562"}}},{"id":"Click_Box_204","class":"TODO::Senthil","instance":"Click_Box_204","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_289","class":"TODO::Senthil","instance":"Green_underline_289","roles":{}},{"id":"What_is_ACPI_1281","class":"TODO::Senthil","instance":"What_is_ACPI_1281","title":"ASL Control Methods  ","roles":{"textData":{}}},{"id":"Text_Caption_1282","class":"TODO::Senthil","instance":"Text_Caption_1282","title":"Previous slides described named objects and their data types as hard-coded values. However, some named object values may need to be computed by performing operations on data. If a named object requires such computation, it needs to be defined as an ASL control method (or “method” for short).  Methods contain executable (AML) code that can perform operations on ASL data. The example shown here is a DSDT DefinitionBlock containing a method that sets INT1 to 0. If MTH1 is called, it stores the value 0x00 to INT1. This value persists until the OS shuts down or another control method changes the value. In other words, if the OS evaluates INT1 after evaluating MTH1, the value of INT1 will be 0x00.  ","roles":{"textData":{}}},{"id":"Text_Caption_1311","class":"TODO::Senthil","instance":"Text_Caption_1311","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x1234) // define INT1 to be 0x1234     Method (MTH1)     {         INT1 = 0x00     // store 0x00 to INT1     } } ","roles":{"textData":{}}},{"id":"Slide118677","class":"Normal Slide","instance":"ASL Control Methods","thumbnail":"","children":["si74803","si116929","Click_Box_204","What_is_ACPI_1281","Text_Caption_1282","Text_Caption_1311"],"roles":{"slide":{"durationInFrames":1638},"navigation":{"navid":"Slide118677"}}},{"id":"Click_Box_209","class":"TODO::Senthil","instance":"Click_Box_209","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1328","class":"TODO::Senthil","instance":"Text_Caption_1328","title":"A control method can reference any named object that exists within the current method scope (in this example MTH1), or anywhere in the ACPI Namespace except within other methods. Named objects created inside methods are temporary (created on the stack), and no longer accessible once the method execution completes.  Methods may also perform a sequence of actions on hardware: for example, reading and writing registers by using fields within OperationRegions as described earlier. ","roles":{"textData":{}}},{"id":"Text_Caption_1329","class":"TODO::Senthil","instance":"Text_Caption_1329","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x1234) // define INT1 to be 0x1234     Method (MTH1)     {         INT1 = 0x00     // store 0x00 to INT1     } } ","roles":{"textData":{}}},{"id":"Green_underline_323","class":"TODO::Senthil","instance":"Green_underline_323","roles":{}},{"id":"What_is_ACPI_1433","class":"TODO::Senthil","instance":"What_is_ACPI_1433","title":"ASL Control Methods  ","roles":{"textData":{}}},{"id":"Slide119581","class":"Normal Slide","instance":"ASL Control Methods","thumbnail":"","children":["si74803","si116929","Click_Box_209","Text_Caption_1328","Text_Caption_1329","What_is_ACPI_1433"],"roles":{"slide":{"durationInFrames":873},"navigation":{"navid":"Slide119581"}}},{"id":"Click_Box_172","class":"TODO::Senthil","instance":"Click_Box_172","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1192","class":"TODO::Senthil","instance":"Text_Caption_1192","title":"Control methods have the syntax shown to the right.   Where: MethodName - Name of the Control Method Object  NumArgs - number of arguments. Arguments are referenced as Arg0 through Arg6  SerializeRule - states whether this control method can be entered by multiple threads (discussed in more detail later).   There are also two other optional parameters for a control method:  a list of types for the arguments, and a return type.   This syntax will be used throughout this tutorial for simplicity.   The definition of MTH1 shown previously leaves out NumArgs and SerializeRule. If these parameters are not specified, they are set to 0 and NotSerialized respectively. TermList is a list of ASL terms that get executed when the method name is evaluated by the OS.  ","roles":{"textData":{}}},{"id":"Text_Caption_1315","class":"TODO::Senthil","instance":"Text_Caption_1315","title":"Method (MethodName, NumArgs, SerializeRule) {     TermList // A list of ASL terms } ","roles":{"textData":{}}},{"id":"Green_underline_324","class":"TODO::Senthil","instance":"Green_underline_324","roles":{}},{"id":"What_is_ACPI_1434","class":"TODO::Senthil","instance":"What_is_ACPI_1434","title":"ASL Control Methods  ","roles":{"textData":{}}},{"id":"Slide116450","class":"Normal Slide","instance":"ASL Control Methods","thumbnail":"","children":["si74803","si116929","Click_Box_172","Text_Caption_1192","Text_Caption_1315","What_is_ACPI_1434"],"roles":{"slide":{"durationInFrames":1449},"navigation":{"navid":"Slide116450"}}},{"id":"Click_Box_208","class":"TODO::Senthil","instance":"Click_Box_208","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1314","class":"TODO::Senthil","instance":"Text_Caption_1314","title":"To summarize, an ASL control method is defined by a method name, the number of parameters, the serialization rule, and a list of ASL terms. Control methods can operate on named objects that are in the ACPI namespace, method arguments, or local variables. Within the TermList, a Return() keyword can be used to denote a value to return to the caller of the method.  ASL methods are allowed to have up to seven arguments and eight local variables. Arguments are referenced as Arg0 through Arg6 and locals are referenced as Local0 through Local7. ASL methods can be called by other ASL methods or by the OS through the AML interpreter.       ","roles":{"textData":{}}},{"id":"Text_Caption_1368","class":"TODO::Senthil","instance":"Text_Caption_1368","title":"Method (ADD, 2) {   Return (Arg0 + Arg1) } ","roles":{"textData":{}}},{"id":"Green_underline_325","class":"TODO::Senthil","instance":"Green_underline_325","roles":{}},{"id":"What_is_ACPI_1435","class":"TODO::Senthil","instance":"What_is_ACPI_1435","title":"ASL Control Methods  ","roles":{"textData":{}}},{"id":"Slide119290","class":"Normal Slide","instance":"ASL Control Methods","thumbnail":"","children":["si74803","si116929","Click_Box_208","Text_Caption_1314","Text_Caption_1368","What_is_ACPI_1435"],"roles":{"slide":{"durationInFrames":1287},"navigation":{"navid":"Slide119290"}}},{"id":"Click_Box_173","class":"TODO::Senthil","instance":"Click_Box_173","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_254","class":"TODO::Senthil","instance":"Green_underline_254","roles":{}},{"id":"What_is_ACPI_1193","class":"TODO::Senthil","instance":"What_is_ACPI_1193","title":"Basic ASL Operators  ","roles":{"textData":{}}},{"id":"Text_Caption_1194","class":"TODO::Senthil","instance":"Text_Caption_1194","title":"The first example on this page shows how to print \"Hello world\" to a debug console using ASL.  Printf is similar to the same command in C.  ","roles":{"textData":{}}},{"id":"Text_Caption_1316","class":"TODO::Senthil","instance":"Text_Caption_1316","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (GRT1)     {         Printf (\"Hello world\")     } } ","roles":{"textData":{}}},{"id":"Text_Caption_1317","class":"TODO::Senthil","instance":"Text_Caption_1317","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (STR1, \"it is a wonderful day\")     Method (GRT1)     {         Printf (\"Hello world, %o\", STR1)     } }  ","roles":{"textData":{}}},{"id":"Text_Caption_1439","class":"TODO::Senthil","instance":"Text_Caption_1439","title":"The format specifier “%o” can be used to insert the value of a named object. The example shown here will append the contents of STR1 to produce the output \"Hello world, it is a wonderful day\".  ","roles":{"textData":{}}},{"id":"Slide116509","class":"Normal Slide","instance":"Basic ASL Operators","thumbnail":"","children":["si74803","si116929","Click_Box_173","What_is_ACPI_1193","Text_Caption_1194","Text_Caption_1316","Text_Caption_1317","Text_Caption_1439"],"roles":{"slide":{"durationInFrames":675},"navigation":{"navid":"Slide116509"}}},{"id":"Text_Caption_1198","class":"TODO::Senthil","instance":"Text_Caption_1198","title":"ASL provides a variety of mathematical, bit-wise, and logical operators as listed here. Note that both infix operators (ASL 2.0) and prefix (legacy) operators are supported. Infix operators are considered more readable and hence are recommended.  ","roles":{"textData":{}}},{"id":"Click_Box_175","class":"TODO::Senthil","instance":"Click_Box_175","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_256","class":"TODO::Senthil","instance":"Green_underline_256","roles":{}},{"id":"What_is_ACPI_1197","class":"TODO::Senthil","instance":"What_is_ACPI_1197","title":"Mathematical Operators ","roles":{"textData":{}}},{"id":"Image_315","class":"TODO::Senthil","instance":"Image_315","roles":{}},{"id":"Image_316","class":"TODO::Senthil","instance":"Image_316","roles":{}},{"id":"Image_317","class":"TODO::Senthil","instance":"Image_317","roles":{}},{"id":"Text_Caption_1356","class":"TODO::Senthil","instance":"Text_Caption_1356","title":"Note: Boolean types do not exist in ASL. Instead, logical operators treat integers greater than or equal to 1 as \"true\" and 0 as \"false\". ","roles":{"textData":{}}},{"id":"Slide116607","class":"Normal Slide","instance":"Mathematical Operators","thumbnail":"","children":["si74803","si116929","Text_Caption_1198","Click_Box_175","What_is_ACPI_1197","Image_315","Image_316","Image_317","Text_Caption_1356"],"roles":{"slide":{"durationInFrames":807},"navigation":{"navid":"Slide116607"}}},{"id":"Click_Box_177","class":"TODO::Senthil","instance":"Click_Box_177","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_258","class":"TODO::Senthil","instance":"Green_underline_258","roles":{}},{"id":"What_is_ACPI_1201","class":"TODO::Senthil","instance":"What_is_ACPI_1201","title":"Control Flow Operators ","roles":{"textData":{}}},{"id":"Text_Caption_1202","class":"TODO::Senthil","instance":"Text_Caption_1202","title":"ASL also supports control flow operators such as if, else, and while - as shown in the example here.     ","roles":{"textData":{}}},{"id":"Text_Caption_1333","class":"TODO::Senthil","instance":"Text_Caption_1333","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x02)      Method (CTDW, 1)     {         Local0 = Arg0         While (Local0)         {             Printf (\"%o\",Local0)             Local0--;         }     }     Method (CTUP, 1)     {         Local0 = Arg0         While (Local0 < 10)         {             If (!(Local0 % 2))             {                 Printf (\"%o is even\", Local0)             }             Else             {                 Printf (\"%o is odd\", Local0)             }             Local0++;         }     } } ","roles":{"textData":{}}},{"id":"Slide116705","class":"Normal Slide","instance":"Control Flow Operators","thumbnail":"","children":["si74803","si116929","Click_Box_177","What_is_ACPI_1201","Text_Caption_1202","Text_Caption_1333"],"roles":{"slide":{"durationInFrames":198},"navigation":{"navid":"Slide116705"}}},{"id":"Click_Box_174","class":"TODO::Senthil","instance":"Click_Box_174","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_255","class":"TODO::Senthil","instance":"Green_underline_255","roles":{}},{"id":"What_is_ACPI_1195","class":"TODO::Senthil","instance":"What_is_ACPI_1195","title":"String Operators ","roles":{"textData":{}}},{"id":"Text_Caption_1204","class":"TODO::Senthil","instance":"Text_Caption_1204","title":"Strings in ASL are null-terminated arrays of ASCII characters. They are frequently used for the following cases: debugging messages, macros that convert strings to buffers, and predefined names.  As previous examples have demonstrated, the Printf macro is used to print messages to the console. This macro is a convenient way to add debugging during development. Printf can concatenate multiple strings to one message. If strings need to be built prior to the Printf invocation, the Concatenate operator can be used.   In the example shown here, methods DBG1 and DBG2 result in the same output: “Hello world, it is a wonderful day”  ","roles":{"textData":{}}},{"id":"Text_Caption_1318","class":"TODO::Senthil","instance":"Text_Caption_1318","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (STR1, \"it is a wonderful day\")     Method (DBG1)     {         Printf (\"Hello world, %o\", STR1)     }     Method (DBG2)     {         Local0 = Concatenate (\"Hello world, \", STR1)         Printf (\"%o\", Local0)     } } ","roles":{"textData":{}}},{"id":"Slide116558","class":"Normal Slide","instance":"String Operators","thumbnail":"","children":["si74803","si116929","Click_Box_174","What_is_ACPI_1195","Text_Caption_1204","Text_Caption_1318"],"roles":{"slide":{"durationInFrames":1152},"navigation":{"navid":"Slide116558"}}},{"id":"Click_Box_205","class":"TODO::Senthil","instance":"Click_Box_205","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1285","class":"TODO::Senthil","instance":"Text_Caption_1285","title":"In addition to Concatenate, there are several useful ASL macros that generate buffers from strings. One such macro is ToUUID. This macro takes a string of the form aabbccdd-eeff-gghh-iijj-kkllmmnnoopp, where aa through pp represent one-byte values using hexadecimal characters. This gets converted to a 16-byte buffer that looks like the example to the right.   This mixture of little endian and big-endian encoding UUID is called a mixed-endian format. The use of strings and the ToUUID macro is a convenient way to avoid having to manually encode the mixed-endian format. There are many other macros that provide similar convenience such as EISAID.  ","roles":{"textData":{}}},{"id":"Text_Caption_1319","class":"TODO::Senthil","instance":"Text_Caption_1319","title":"Buffer() {     dd, cc, bb, aa,     ff, ee,     hh, gg,     ii, jj, kk, ll, mm, nn, oo, pp } ","roles":{"textData":{}}},{"id":"Green_underline_326","class":"TODO::Senthil","instance":"Green_underline_326","roles":{}},{"id":"What_is_ACPI_1436","class":"TODO::Senthil","instance":"What_is_ACPI_1436","title":"String Operators ","roles":{"textData":{}}},{"id":"Slide118756","class":"Normal Slide","instance":"String Operators 2","thumbnail":"","children":["si74803","si116929","Click_Box_205","Text_Caption_1285","Text_Caption_1319","What_is_ACPI_1436"],"roles":{"slide":{"durationInFrames":936},"navigation":{"navid":"Slide118756"}}},{"id":"Click_Box_176","class":"TODO::Senthil","instance":"Click_Box_176","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_257","class":"TODO::Senthil","instance":"Green_underline_257","roles":{}},{"id":"What_is_ACPI_1199","class":"TODO::Senthil","instance":"What_is_ACPI_1199","title":"Using Buffer and Package Elements Recall that buffers are like C arrays where each element is a single byte. One way to access elements in a buffer is to use the index operator []. Like arrays in C, buffers are indexed starting at 0. However, there is one catch: an index operator in ASL returns a reference to the buffer element. So it needs to be dereferenced using the DeRefOf operator before it can be used. The example below shows a method that prints each element of the buffer passed as arg0 to the console in userspace.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (IDXA, 1)     {         local0 = sizeof(arg0)         local1 = 0 // use this as the index value         printf (\"The size of the buffer is %o\", local0)         while (local0 > local1)         {             printf (\"%o\", Derefof(arg0[local1]))             local1++         }     } }  Packages are similar to buffers except their elements can contain Strings, Integers, Buffers, and other named objects. The above method works for both buffers and packages.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (OVFL, 1) // Causes a buffer overrun     {         local0 = sizeof(arg0)         local1 = 0 // use this as the index value         printf (\"The size of the buffer is %o\", local0)         while (local0 >= local1)         {             printf (\"%o\", derefof(arg0[local1])) //runtime error             local1++         }         printf (\"Complete\")     } }  Unlike C, out-of-bounds accesses in buffers and packages result in runtime errors from the interpreter. In the example above, OVFL access the input buffer or package one past the max index when local0 == local1. When the runtime error occurs the method execution is terminated. This means that local1++ and printf (\"Complete\") is not executed after the runtime error. 5.4.1  Exercises 1.\tWhat happens when the DeRefOf operator is removed in IDXA?  2.\tWhich component invokes the runtime error?  3.\tWrite a method to return a buffer where the length of the buffer is passed as arg0.  4.\tWrite an ASL method to compute the sum of all elements in a buffer. A buffer will be passed to this method as arg0.  5.5  Bit fields Due to the low-level nature of ASL, it is often convenient to manipulate bits inside of buffers by assinging a name to a region of bits and performing operations on it as if it were a named object. This saves the programmer from constantly indexing buffer elements.   The CreateWordField overlays a named object over BUFF that spans 2 bytes. This allows a simple approach to work with two contiguous elements of BUFF. It’s also important to note that CreateWordField operator adds the name DWRD to the ACPI namespace. Here is the syntax:  CreateWordField (SourceBuffer, ByteIndex, FieldName)  •\tSourceBuffer buffer that the field will overlay  •\tByteIndex starting bit offset within the source buffer  •\tFieldName a nameseg of this Field  Here is an example of two methods that perform similar computations:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (BUFF, buffer() {0xff,0x2f,0xea,0x5c,0x2b})     CreateWordField (BUFF, 0x01, DWRD)      //XCH1 and XCH2 will assign BUFF[1] and BUFF[2] to 0x00      Method (XCH1) // This uses 4 operands     {  BUFF[1] = 0x00  BUFF[2] = 0x00     }      Method (XCH2) // This uses 1     {         DWRD = 0x0000     } }  XCH1 and XCH2 result in the same outcomes. However, XCH2 incurs less instructions. To provide more flexibility, ASL supports opcodes similar to CreateWordField. Below is a list of opcodes that create named objects that span the length of buffers with various lengths: •\tCreateBitField - Length: 1 bit  •\tCreateByteField - Length: 1 byte  •\tCreateWordField - Length: 2 bytes  •\tCreateDWordField - Length: 4 bytes  •\tCreateQWordField - Length: 8 bytes  •\tCreateField - Length: Arbitrary  5.5.1  Exercises 1.\tWhat is the value of DWRD after XCH1 is evaluated?  2.\tWrite a method to clear bits 5 through 12 of BUFF without using the opcodes discussed above. Write another method to do the same thing using CreateField.  5.6  ResourceTemplates Buffers are useful for encoding information that describe resources used by device drivers such as IRQ, DMA, and I/O ports. Each of these resources has a particular format. The following buffer describes an I/O resource:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (RES1, buffer(){         0x47, 0x01, 0x62, 0x00, 0x62, 0x00, 0x00, 0x01,  0x47, 0x01, 0x66, 0x00, 0x66, 0x00, 0x00, 0x01,  0x79, 0x00     }) }  When a driver wants to understand the configuration of devices through ACPI, it calls the AML interpreter for a named object which may be assigned to a buffer that is similar to BUF1. Programming this by hand can be a leads to mistakes because this notation lacks semantic meanings. If device resources need to be described, the ResourceTemplate macro should be used. By doing so the buffer can be encoded like so:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (RES2,          ResourceTemplate(){             IO(Decode16, 0x62, 0x62, 0, 1)             IO(Decode16, 0x66, 0x66, 0, 1)     })  }  When compiled, RES2 will be translated during compilation to look exactly like RES1. For RES1 and RES2, the translations are depicted in the image below.   In order read or write to elements of RES2, create bit fields that overlay a parameter and write to the bit field. In the above example, the second parameter of the first IO macro can be written like this:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (RES2,          ResourceTemplate(){             IO(Decode16, 0x62, 0x62, 0, 1, IOP1)             IO(Decode16, 0x66, 0x66, 0, 1, IOP2)     })      Method (WRRT, arg1)     {         /*          * According to the ACPI specification, the second field of the IO          * macro is 16 bits. Therefore, use CreateWordField to overlay a region          * that is 16 bits in length.          */         CreateWordField (RES2, \\IOP1._MIN, MINF)         MINF = 0x1234 // This will write 0x1234 to the second field in IOP1.     }   }  As a cautionary note, IOP1 and IOP2 are macros that get transformed during compilation. These labels do not get inserted in the ACPI namespace. However, RES2 gets inserted to the namespace and the contents of IOP1 and IOP2 will be available for use by the driver. In reality, IOP1, IOP2, and _MIN are macros that translate to integers that indicate an offset into RES2.   During compilation IOP1._MIN and other offset fields within the CreateField declaration are translated to the following integer values:   5.6.1  Exercises 1.\tWrite a method to change _MAX of IOP2 to 0xABCD  5.7  Control Method Calling Convention ASL methods have a calling convention called \"call-by-reference-constant\". In this calling convention, method arguments are passed as references to reduce overhead in copying data. To reduce aliasing issues, control method arguments are essentially passed as constants and cannot be easily overwritten. One exception to this rule is when an argument contains references. In this case, the object value can be changed by dereferencing.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x00)     Method (CHNG, 1)     {         arg0 = 0x1234     }     Method (M001)     {         M000(INT1)     } }  In the table above, M001 passes INT1 to M000 and arg0 is incremented. However, the value of INT1 will remain as 0x00. However, arguments can be overwritten if they are references. In order to access package or buffer elements, the index operator [] is needed. After evaluating M001, the value of INT1 will remain 0x01. However, PKG1 will contain 0x13 and BUF1 will contain 0x20.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x01)        Name (PKG1, package() {INT1})     Name (BUF1, buffer() {0x0E})        Method (CHNG, 1)     {         arg0[0] = 0x12 // overwrite     }        Method (M001)     {         CHNG (PKG1)         CHNG (BUF1)     } }  5.7.1  Exercises 1.\tWrite a method to increment all elements of a buffer or a package containing integers by 5. The buffer or package will be passed as arg0.  5.8  Tip: avoid declaring Named Objects in Methods In addition to executable procedures, Named objects can be declared inside of methods. This is highly discouraged because any named object declared inside a method declaration only exists for the duration of the method execution. The named object gets inserted to the ACPI namespace and removed from the namespace at the end of the method. This is a waste of computation for the AML interpreter, especially if the entire purpose of declaring a named object is for the OS to interact with it. If a named object is only present for the method execution, the only part of the ASL that can refer to the named object is the method itself. In order to store temporary values, use local0 through local7. 5.9  Other ASL Operators To view a full list of ASL operators, consult section 19.5 of the ACPI specification.   ","roles":{"textData":{}}},{"id":"Text_Caption_1200","class":"TODO::Senthil","instance":"Text_Caption_1200","title":"Recall that ASL buffers are like byte arrays in C, where each element of the buffer is a single byte. One way to access these elements in ASL is to use the index operator [], which indexes the buffer starting at 0 (like C).   Note that an ASL index operator returns a reference (pointer) to the buffer element, rather than the value in the buffer. To get the value associated with the index, use the DeRefOf operator. For example, the method shown here prints each element of the buffer, passed as Arg0 to the console in userspace.  Packages are similar to buffers, except that their elements can contain strings, integers, buffers, and other named objects. The method described here works for both buffers and packages. ","roles":{"textData":{}}},{"id":"Text_Caption_1320","class":"TODO::Senthil","instance":"Text_Caption_1320","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (IDXA, 1)     {         Local0 = Sizeof(Arg0)         Local1 = 0 // use this as the index value         Printf (\"The size of the buffer is %o\", Local0)         While (Local0 > Local1)         {             Printf (\"%o\", Derefof(Arg0[Local1]))             Local1++         }     } }  ","roles":{"textData":{}}},{"id":"Slide116656","class":"Normal Slide","instance":"Using Buffer and Package Elements","thumbnail":"","children":["si74803","si116929","Click_Box_176","What_is_ACPI_1199","Text_Caption_1200","Text_Caption_1320"],"roles":{"slide":{"durationInFrames":1266},"navigation":{"navid":"Slide116656"}}},{"id":"Click_Box_191","class":"TODO::Senthil","instance":"Click_Box_191","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1246","class":"TODO::Senthil","instance":"Text_Caption_1246","title":"In ASL (unlike C), out-of-bounds accesses in buffers and packages result in runtime errors from the interpreter. In the example shown here, OVFL tries to access the input buffer or package one past the max index when Local0 == Local1.   When an ASL runtime error occurs, the method execution is terminated. In the example here, this means that local1++ and printf (\"Complete\") are not executed after the runtime error. ","roles":{"textData":{}}},{"id":"Text_Caption_1321","class":"TODO::Senthil","instance":"Text_Caption_1321","title":"DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (OVFL, 1) // Causes a buffer overrun     {         Local0 = Sizeof(Arg0)         Local1 = 0 // use this as the index value         Printf (\"The size of the buffer is %o\", Local0)         While (Local0 >= Local1)         {             Printf (\"%o\", Derefof(Arg0[Local1]))             //runtime error when Local0 == Local1             Local1++         }         Printf (\"Complete\")     } }  ","roles":{"textData":{}}},{"id":"Green_underline_327","class":"TODO::Senthil","instance":"Green_underline_327","roles":{}},{"id":"What_is_ACPI_1437","class":"TODO::Senthil","instance":"What_is_ACPI_1437","title":"Using Buffer and Package Elements Recall that buffers are like C arrays where each element is a single byte. One way to access elements in a buffer is to use the index operator []. Like arrays in C, buffers are indexed starting at 0. However, there is one catch: an index operator in ASL returns a reference to the buffer element. So it needs to be dereferenced using the DeRefOf operator before it can be used. The example below shows a method that prints each element of the buffer passed as arg0 to the console in userspace.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (IDXA, 1)     {         local0 = sizeof(arg0)         local1 = 0 // use this as the index value         printf (\"The size of the buffer is %o\", local0)         while (local0 > local1)         {             printf (\"%o\", Derefof(arg0[local1]))             local1++         }     } }  Packages are similar to buffers except their elements can contain Strings, Integers, Buffers, and other named objects. The above method works for both buffers and packages.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Method (OVFL, 1) // Causes a buffer overrun     {         local0 = sizeof(arg0)         local1 = 0 // use this as the index value         printf (\"The size of the buffer is %o\", local0)         while (local0 >= local1)         {             printf (\"%o\", derefof(arg0[local1])) //runtime error             local1++         }         printf (\"Complete\")     } }  Unlike C, out-of-bounds accesses in buffers and packages result in runtime errors from the interpreter. In the example above, OVFL access the input buffer or package one past the max index when local0 == local1. When the runtime error occurs the method execution is terminated. This means that local1++ and printf (\"Complete\") is not executed after the runtime error. 5.4.1  Exercises 1.\tWhat happens when the DeRefOf operator is removed in IDXA?  2.\tWhich component invokes the runtime error?  3.\tWrite a method to return a buffer where the length of the buffer is passed as arg0.  4.\tWrite an ASL method to compute the sum of all elements in a buffer. A buffer will be passed to this method as arg0.  5.5  Bit fields Due to the low-level nature of ASL, it is often convenient to manipulate bits inside of buffers by assinging a name to a region of bits and performing operations on it as if it were a named object. This saves the programmer from constantly indexing buffer elements.   The CreateWordField overlays a named object over BUFF that spans 2 bytes. This allows a simple approach to work with two contiguous elements of BUFF. It’s also important to note that CreateWordField operator adds the name DWRD to the ACPI namespace. Here is the syntax:  CreateWordField (SourceBuffer, ByteIndex, FieldName)  •\tSourceBuffer buffer that the field will overlay  •\tByteIndex starting bit offset within the source buffer  •\tFieldName a nameseg of this Field  Here is an example of two methods that perform similar computations:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (BUFF, buffer() {0xff,0x2f,0xea,0x5c,0x2b})     CreateWordField (BUFF, 0x01, DWRD)      //XCH1 and XCH2 will assign BUFF[1] and BUFF[2] to 0x00      Method (XCH1) // This uses 4 operands     {  BUFF[1] = 0x00  BUFF[2] = 0x00     }      Method (XCH2) // This uses 1     {         DWRD = 0x0000     } }  XCH1 and XCH2 result in the same outcomes. However, XCH2 incurs less instructions. To provide more flexibility, ASL supports opcodes similar to CreateWordField. Below is a list of opcodes that create named objects that span the length of buffers with various lengths: •\tCreateBitField - Length: 1 bit  •\tCreateByteField - Length: 1 byte  •\tCreateWordField - Length: 2 bytes  •\tCreateDWordField - Length: 4 bytes  •\tCreateQWordField - Length: 8 bytes  •\tCreateField - Length: Arbitrary  5.5.1  Exercises 1.\tWhat is the value of DWRD after XCH1 is evaluated?  2.\tWrite a method to clear bits 5 through 12 of BUFF without using the opcodes discussed above. Write another method to do the same thing using CreateField.  5.6  ResourceTemplates Buffers are useful for encoding information that describe resources used by device drivers such as IRQ, DMA, and I/O ports. Each of these resources has a particular format. The following buffer describes an I/O resource:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (RES1, buffer(){         0x47, 0x01, 0x62, 0x00, 0x62, 0x00, 0x00, 0x01,  0x47, 0x01, 0x66, 0x00, 0x66, 0x00, 0x00, 0x01,  0x79, 0x00     }) }  When a driver wants to understand the configuration of devices through ACPI, it calls the AML interpreter for a named object which may be assigned to a buffer that is similar to BUF1. Programming this by hand can be a leads to mistakes because this notation lacks semantic meanings. If device resources need to be described, the ResourceTemplate macro should be used. By doing so the buffer can be encoded like so:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (RES2,          ResourceTemplate(){             IO(Decode16, 0x62, 0x62, 0, 1)             IO(Decode16, 0x66, 0x66, 0, 1)     })  }  When compiled, RES2 will be translated during compilation to look exactly like RES1. For RES1 and RES2, the translations are depicted in the image below.   In order read or write to elements of RES2, create bit fields that overlay a parameter and write to the bit field. In the above example, the second parameter of the first IO macro can be written like this:  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (RES2,          ResourceTemplate(){             IO(Decode16, 0x62, 0x62, 0, 1, IOP1)             IO(Decode16, 0x66, 0x66, 0, 1, IOP2)     })      Method (WRRT, arg1)     {         /*          * According to the ACPI specification, the second field of the IO          * macro is 16 bits. Therefore, use CreateWordField to overlay a region          * that is 16 bits in length.          */         CreateWordField (RES2, \\IOP1._MIN, MINF)         MINF = 0x1234 // This will write 0x1234 to the second field in IOP1.     }   }  As a cautionary note, IOP1 and IOP2 are macros that get transformed during compilation. These labels do not get inserted in the ACPI namespace. However, RES2 gets inserted to the namespace and the contents of IOP1 and IOP2 will be available for use by the driver. In reality, IOP1, IOP2, and _MIN are macros that translate to integers that indicate an offset into RES2.   During compilation IOP1._MIN and other offset fields within the CreateField declaration are translated to the following integer values:   5.6.1  Exercises 1.\tWrite a method to change _MAX of IOP2 to 0xABCD  5.7  Control Method Calling Convention ASL methods have a calling convention called \"call-by-reference-constant\". In this calling convention, method arguments are passed as references to reduce overhead in copying data. To reduce aliasing issues, control method arguments are essentially passed as constants and cannot be easily overwritten. One exception to this rule is when an argument contains references. In this case, the object value can be changed by dereferencing.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x00)     Method (CHNG, 1)     {         arg0 = 0x1234     }     Method (M001)     {         M000(INT1)     } }  In the table above, M001 passes INT1 to M000 and arg0 is incremented. However, the value of INT1 will remain as 0x00. However, arguments can be overwritten if they are references. In order to access package or buffer elements, the index operator [] is needed. After evaluating M001, the value of INT1 will remain 0x01. However, PKG1 will contain 0x13 and BUF1 will contain 0x20.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (INT1, 0x01)        Name (PKG1, package() {INT1})     Name (BUF1, buffer() {0x0E})        Method (CHNG, 1)     {         arg0[0] = 0x12 // overwrite     }        Method (M001)     {         CHNG (PKG1)         CHNG (BUF1)     } }  5.7.1  Exercises 1.\tWrite a method to increment all elements of a buffer or a package containing integers by 5. The buffer or package will be passed as arg0.  5.8  Tip: avoid declaring Named Objects in Methods In addition to executable procedures, Named objects can be declared inside of methods. This is highly discouraged because any named object declared inside a method declaration only exists for the duration of the method execution. The named object gets inserted to the ACPI namespace and removed from the namespace at the end of the method. This is a waste of computation for the AML interpreter, especially if the entire purpose of declaring a named object is for the OS to interact with it. If a named object is only present for the method execution, the only part of the ASL that can refer to the named object is the method itself. In order to store temporary values, use local0 through local7. 5.9  Other ASL Operators To view a full list of ASL operators, consult section 19.5 of the ACPI specification.   ","roles":{"textData":{}}},{"id":"Slide117777","class":"Normal Slide","instance":"Using Buffer and Package Elements 2","thumbnail":"","children":["si74803","si116929","Click_Box_191","Text_Caption_1246","Text_Caption_1321","What_is_ACPI_1437"],"roles":{"slide":{"durationInFrames":852},"navigation":{"navid":"Slide117777"}}},{"id":"Click_Box_181","class":"TODO::Senthil","instance":"Click_Box_181","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_264","class":"TODO::Senthil","instance":"Green_underline_264","roles":{}},{"id":"What_is_ACPI_1225","class":"TODO::Senthil","instance":"What_is_ACPI_1225","title":"Bit Fields  ","roles":{"textData":{}}},{"id":"Text_Caption_1226","class":"TODO::Senthil","instance":"Text_Caption_1226","title":"Due to the low-level nature of ASL, it is often convenient to manipulate bits inside of buffers by assigning a name to a region of bits, and performing operations on this region as if it were a named object. This saves the developer from having to frequently index buffer elements.  ","roles":{"textData":{}}},{"id":"Text_Caption_1322","class":"TODO::Senthil","instance":"Text_Caption_1322","title":"The operator CreateWordField defines a named object overlaying BUFF that spans two bytes. This allows a simple approach to work with two contiguous elements of BUFF. Also note that the CreateWordField operator adds the name BFLD to the ACPI Namespace. Here is the syntax:  CreateWordField (SourceBuffer, ByteIndex, FieldName)  •\tSourceBuffer: a buffer that the field will overlay  •\tByteIndex: the starting bit offset within the source buffer  •\tFieldName: the NameSeg of this field   ","roles":{"textData":{}}},{"id":"Image_307","class":"TODO::Senthil","instance":"Image_307","roles":{}},{"id":"Slide117237","class":"Normal Slide","instance":"Bit Fields","thumbnail":"","children":["si74803","si116929","Click_Box_181","What_is_ACPI_1225","Text_Caption_1226","Text_Caption_1322","Image_307"],"roles":{"slide":{"durationInFrames":1512},"navigation":{"navid":"Slide117237"}}},{"id":"Click_Box_193","class":"TODO::Senthil","instance":"Click_Box_193","roles":{"click":{"subtype":"button"}}},{"id":"Text_Caption_1250","class":"TODO::Senthil","instance":"Text_Caption_1250","title":"The ASL example here shows two methods that perform similar computations. XCH1 and XCH2 result in the same outcome, but XCH2 uses fewer instructions.  DefinitionBlock (\"\", \"DSDT\", 2, \"\", \"\", 0x0) {     Name (BUFF, Buffer() {0xff,0x2f,0xea,0x5c,0x2b})     CreateWordField (BUFF, 0x01, BFLD)      //XCH1 and XCH2 will assign BUFF[1] and BUFF[2] to 0x00      Method (XCH1)    // This uses 4 operands     {        BUFF[1] = 0x00        BUFF[2] = 0x00     }      Method (XCH2)    // This uses 1 operand     {         BFLD = 0x0000     } }   ","roles":{"textData":{}}},{"id":"Text_Caption_1251","class":"TODO::Senthil","instance":"Text_Caption_1251","title":"To provide more flexibility, ASL also supports other opcodes similar to CreateWordField. Below is a list of opcodes that create named objects that span portions of buffers with various lengths: •\tCreateBitField - Length: 1 bit  •\tCreateByteField - Length: 1 byte  •\tCreateWordField - Length: 2 bytes  •\tCreateDWordField - Length: 4 bytes  •\tCreateQWordField - Length: 8 bytes  •\tCreateField - Length: an arbitrary number of bits ","roles":{"textData":{}}},{"id":"What_is_ACPI_1438","class":"TODO::Senthil","instance":"What_is_ACPI_1438","title":"Bit Fields  ","roles":{"textData":{}}},{"id":"Green_underline_328","class":"TODO::Senthil","instance":"Green_underline_328","roles":{}},{"id":"Slide117885","class":"Normal Slide","instance":"Bit Fields 2","thumbnail":"","children":["si74803","si116929","Click_Box_193","Text_Caption_1250","Text_Caption_1251","What_is_ACPI_1438"],"roles":{"slide":{"durationInFrames":1191},"navigation":{"navid":"Slide117885"}}},{"id":"Click_Box_184","class":"TODO::Senthil","instance":"Click_Box_184","roles":{"click":{"subtype":"button"}}},{"id":"Green_underline_267","class":"TODO::Senthil","instance":"Green_underline_267","roles":{}},{"id":"What_is_ACPI_1231","class":"TODO::Senthil","instance":"What_is_ACPI_1231","title":"Tip: Avoid Declaring Named Objects in Methods  ","roles":{"textData":{}}},{"id":"Text_Caption_1232","class":"TODO::Senthil","instance":"Text_Caption_1232","title":"Named objects, that are normally declared in executable procedures, can also be declared inside of methods. But the latter approach is highly discouraged, because any named object declared inside a method declaration only exists for the duration of the method execution. The named object gets inserted to the ACPI Namespace and removed from the namespace at the end of the method.   This is a waste of computation for the AML interpreter, especially if the entire purpose of declaring a named object is for the OS to interact with it. If a named object is only present for the method execution, the only part of the ASL that can refer to the named object is the method itself. In order to store temporary values, use local0 through local7. ","roles":{"textData":{}}},{"id":"Text_Caption_1421","class":"TODO::Senthil","instance":"Text_Caption_1421","title":"For a full list of ASL operators, see chapter 19 of the ACPI specification.  ","roles":{"textData":{}}},{"id":"Green_underline_321","class":"TODO::Senthil","instance":"Green_underline_321","roles":{}},{"id":"What_is_ACPI_1422","class":"TODO::Senthil","instance":"What_is_ACPI_1422","title":"Other ASL Operators  ","roles":{"textData":{}}},{"id":"Slide117399","class":"Normal Slide","instance":"Closing comments","thumbnail":"","children":["si74803","si116929","Click_Box_184","What_is_ACPI_1231","Text_Caption_1232","Text_Caption_1421","What_is_ACPI_1422"],"roles":{"slide":{"durationInFrames":1809},"navigation":{"navid":"Slide117399"}}},{"id":"Text_Caption_722","class":"TODO::Senthil","instance":"Text_Caption_722","title":"Module Completion  ","roles":{"textData":{}}},{"id":"Text_Caption_723","class":"TODO::Senthil","instance":"Text_Caption_723","title":"Congratulations! You’ve completed this module. Close your browser to exit. ","roles":{"textData":{}}},{"id":"Image_198","class":"TODO::Senthil","instance":"Image_198","roles":{}},{"id":"Text_Caption_724","class":"TODO::Senthil","instance":"Text_Caption_724","title":"Module Completion  ","roles":{"textData":{}}},{"id":"Button_344","class":"TODO::Senthil","instance":"Button_344","roles":{"click":{"subtype":"button"}}},{"id":"si78825","class":"TODO::Senthil","roles":{"click":{"subtype":"button"}}},{"id":"si78839","class":"TODO::Senthil","roles":{"click":{"subtype":"button"}}},{"id":"Click_Box_68","class":"TODO::Senthil","instance":"Click_Box_68","roles":{"click":{"subtype":"button"}}},{"id":"Slide78225","class":"Normal Slide","instance":"Module Completion","thumbnail":"","children":["si74803","si116929","Text_Caption_722","Text_Caption_723","Image_198","Text_Caption_724","Button_344","si78825","si78839","Click_Box_68"],"roles":{"slide":{"durationInFrames":90},"navigation":{"navid":"Slide78225"}}},{"id":"Pool492","class":"pool","roles":{"pool":{"id":492,"name":"Pool1","questions":[]}}},{"id":"Intro to ASL","class":"project","title":"Intro to ASL","children":["Slide17873","Slide125177","Slide116796","Slide115607","Slide119646","Slide112989","Slide112939","Slide115696","Slide116886","Slide111028","Slide113279","Slide124189","Slide113339","Slide120437","Slide113489","Slide113539","Slide113639","Slide113689","Slide114412","Slide114462","Slide119149","Slide114512","Slide114562","Slide118677","Slide119581","Slide116450","Slide119290","Slide116509","Slide116607","Slide116705","Slide116558","Slide118756","Slide116656","Slide117777","Slide117237","Slide117885","Slide117399","Slide78225"],"roles":{"quiz":{"id":450,"branched":false,"submitAll":false,"review":false,"questions":[],"minScore":0,"maxScore":0,"passScore":10}}}],"contentSettings":{"global":{"branchAware":false},"toc":{"navigationEnabled":true,"navigateVisitedSlides":false,"collapseAll":false,"showTopicDuration":false,"statusFlag":true,"selfPaced":false,"showSearch":false,"enabled":true},"playbar":{"enabled":true,"cc":false,"playPause":true,"back":true,"forward":true,"rewind":false,"close":false,"mute":true,"progressBar":true}},"contentReporting":{"CCCriteria":"launch_content","SCCriteria":"launch_content","exitNormalIfCompleted":false},"toc":[{"id":"Slide17873","title":"Title slide","visible":true},{"id":"Slide125177","title":"Title slide","visible":false},{"id":"Slide116796","title":"About this Training","visible":true},{"id":"Slide115607","title":"ASL Overview","visible":true},{"id":"Slide119646","title":"ASL Overview","visible":false},{"id":"Slide112989","title":"ASL Example","visible":true},{"id":"Slide112939","title":"ACPI Namespace","visible":true},{"id":"Slide115696","title":"Namespace Hierarchy","visible":true},{"id":"Slide116886","title":"ASL Syntax","visible":true},{"id":"Slide111028","title":"Definition Blocks","visible":true},{"id":"Slide113279","title":"Named Objects","visible":true},{"id":"Slide124189","title":"ObjectName Examples","visible":true},{"id":"Slide113339","title":"Populating the ACPI Namespace","visible":true},{"id":"Slide120437","title":"Simple ASL data types","visible":true},{"id":"Slide113489","title":"ASL Buffers and Package","visible":true},{"id":"Slide113539","title":"ASL Buffers and Package","visible":false},{"id":"Slide113639","title":"Operation Regions and Field","visible":true},{"id":"Slide113689","title":"Operation Regions and Field","visible":false},{"id":"Slide114412","title":"Defining Scopes","visible":true},{"id":"Slide114462","title":"Defining Scopes","visible":false},{"id":"Slide119149","title":"Defining Scopes","visible":false},{"id":"Slide114512","title":"Name Paths","visible":true},{"id":"Slide114562","title":"Predefined Names","visible":true},{"id":"Slide118677","title":"ASL Control Methods","visible":true},{"id":"Slide119581","title":"ASL Control Methods","visible":false},{"id":"Slide116450","title":"ASL Control Methods","visible":false},{"id":"Slide119290","title":"ASL Control Methods","visible":false},{"id":"Slide116509","title":"Basic ASL Operators","visible":true},{"id":"Slide116607","title":"Mathematical Operators","visible":true},{"id":"Slide116705","title":"Control Flow Operators","visible":true},{"id":"Slide116558","title":"String Operators","visible":true},{"id":"Slide118756","title":"String Operators 2","visible":false},{"id":"Slide116656","title":"Using Buffer and Package Elements","visible":true},{"id":"Slide117777","title":"Using Buffer and Package Elements 2","visible":false},{"id":"Slide117237","title":"Bit Fields","visible":true},{"id":"Slide117885","title":"Bit Fields 2","visible":false},{"id":"Slide117399","title":"Closing comments","visible":true},{"id":"Slide78225","title":"Module Completion","visible":true}]}